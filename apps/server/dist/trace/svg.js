"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateSVG = generateSVG;
exports.generateOptimizedSVG = generateOptimizedSVG;
exports.generateStyledSVG = generateStyledSVG;
/**
 * Generate SVG output with VectorWorks-compatible classes
 * Uses fill-rule="evenodd" for proper hole handling
 */
function generateSVG(polygons, width, height, whiteFill = false) {
    const svgPaths = [];
    // Generate path data for each polygon
    for (const polygon of polygons) {
        const pathData = generatePathData(polygon);
        if (pathData) {
            svgPaths.push(pathData);
        }
    }
    // Build SVG content
    const svgContent = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" 
     width="${width}" 
     height="${height}" 
     viewBox="0 0 ${width} ${height}">
  <defs>
    <style>
      .VW_CLASS_Detail {
        fill: none;
        stroke: black;
        stroke-width: 1;
        stroke-linejoin: round;
        stroke-linecap: round;
      }
      .VW_CLASS_Fill {
        fill: white;
        stroke: none;
      }
    </style>
  </defs>
  
  <!-- White fill layer (if enabled) -->
  ${whiteFill ? generateFillLayer(svgPaths) : ''}
  
  <!-- Detail/contour layer -->
  ${generateDetailLayer(svgPaths)}
</svg>`;
    return svgContent;
}
/**
 * Generate SVG path data for a polygon with holes
 * Uses move-to and line-to commands for precise control
 */
function generatePathData(polygon) {
    if (polygon.exterior.length < 3) {
        return null;
    }
    const pathCommands = [];
    // Exterior ring
    const exterior = polygon.exterior;
    pathCommands.push(`M ${formatCoordinate(exterior[0].x)} ${formatCoordinate(exterior[0].y)}`);
    for (let i = 1; i < exterior.length; i++) {
        pathCommands.push(`L ${formatCoordinate(exterior[i].x)} ${formatCoordinate(exterior[i].y)}`);
    }
    pathCommands.push('Z'); // Close exterior path
    // Hole rings
    for (const hole of polygon.holes) {
        if (hole.length < 3)
            continue;
        pathCommands.push(`M ${formatCoordinate(hole[0].x)} ${formatCoordinate(hole[0].y)}`);
        for (let i = 1; i < hole.length; i++) {
            pathCommands.push(`L ${formatCoordinate(hole[i].x)} ${formatCoordinate(hole[i].y)}`);
        }
        pathCommands.push('Z'); // Close hole path
    }
    return pathCommands.join(' ');
}
/**
 * Generate fill layer with white fill and even-odd rule
 */
function generateFillLayer(pathData) {
    if (pathData.length === 0)
        return '';
    const fillPaths = pathData.map(path => `    <path class="VW_CLASS_Fill" fill-rule="evenodd" d="${path}" />`).join('\n');
    return `  <!-- Fill layer -->
  <g id="VW_CLASS_Fill">
${fillPaths}
  </g>
`;
}
/**
 * Generate detail layer with black strokes
 */
function generateDetailLayer(pathData) {
    if (pathData.length === 0)
        return '';
    const detailPaths = pathData.map(path => `    <path class="VW_CLASS_Detail" d="${path}" />`).join('\n');
    return `  <!-- Detail layer -->
  <g id="VW_CLASS_Detail">
${detailPaths}
  </g>`;
}
/**
 * Format coordinate with appropriate precision
 * Limits decimal places to avoid excessive precision
 */
function formatCoordinate(value) {
    return Number(value.toFixed(3)).toString();
}
/**
 * Generate optimized SVG for CAD applications
 * Includes metadata and proper scaling information
 */
function generateOptimizedSVG(polygons, width, height, whiteFill = false, options = {}) {
    const { title = 'Vectorized Image', description = 'Generated by PNG2Vector', units = 'px', scale = 1 } = options;
    const scaledWidth = width * scale;
    const scaledHeight = height * scale;
    // Scale polygons if needed
    const scaledPolygons = scale !== 1 ? scalePolygons(polygons, scale) : polygons;
    const svgPaths = [];
    // Generate path data for each polygon
    for (const polygon of scaledPolygons) {
        const pathData = generatePathData(polygon);
        if (pathData) {
            svgPaths.push(pathData);
        }
    }
    // Build optimized SVG content
    const svgContent = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" 
     xmlns:xlink="http://www.w3.org/1999/xlink"
     width="${scaledWidth}${units}" 
     height="${scaledHeight}${units}" 
     viewBox="0 0 ${scaledWidth} ${scaledHeight}"
     version="1.1">
  
  <title>${escapeXml(title)}</title>
  <desc>${escapeXml(description)}</desc>
  
  <metadata>
    <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
             xmlns:dc="http://purl.org/dc/elements/1.1/">
      <rdf:Description>
        <dc:title>${escapeXml(title)}</dc:title>
        <dc:description>${escapeXml(description)}</dc:description>
        <dc:creator>PNG2Vector</dc:creator>
        <dc:format>image/svg+xml</dc:format>
      </rdf:Description>
    </rdf:RDF>
  </metadata>
  
  <defs>
    <style type="text/css"><![CDATA[
      .VW_CLASS_Detail {
        fill: none;
        stroke: #000000;
        stroke-width: ${scale};
        stroke-linejoin: round;
        stroke-linecap: round;
        vector-effect: non-scaling-stroke;
      }
      .VW_CLASS_Fill {
        fill: #ffffff;
        stroke: none;
        fill-rule: evenodd;
      }
    ]]></style>
  </defs>
  
  ${whiteFill ? generateFillLayer(svgPaths) : ''}
  ${generateDetailLayer(svgPaths)}
  
</svg>`;
    return svgContent;
}
/**
 * Scale polygons by a factor
 */
function scalePolygons(polygons, scale) {
    return polygons.map(polygon => ({
        exterior: polygon.exterior.map(point => ({
            x: point.x * scale,
            y: point.y * scale,
        })),
        holes: polygon.holes.map(hole => hole.map(point => ({
            x: point.x * scale,
            y: point.y * scale,
        }))),
    }));
}
/**
 * Escape XML special characters
 */
function escapeXml(text) {
    return text
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
}
/**
 * Generate SVG with custom styling
 */
function generateStyledSVG(polygons, width, height, style = {}) {
    const { strokeColor = '#000000', strokeWidth = 1, fillColor = '#ffffff', backgroundColor = 'transparent', } = style;
    const svgPaths = [];
    // Generate path data for each polygon
    for (const polygon of polygons) {
        const pathData = generatePathData(polygon);
        if (pathData) {
            svgPaths.push(pathData);
        }
    }
    const paths = svgPaths.map(path => `    <path fill="${fillColor}" stroke="${strokeColor}" stroke-width="${strokeWidth}" fill-rule="evenodd" d="${path}" />`).join('\n');
    return `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" 
     width="${width}" 
     height="${height}" 
     viewBox="0 0 ${width} ${height}"
     style="background-color: ${backgroundColor}">
${paths}
</svg>`;
}
//# sourceMappingURL=svg.js.map